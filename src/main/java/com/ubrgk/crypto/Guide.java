package com.ubrgk.crypto;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import org.bitcoinj.core.ECKey;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Scanner;

/**
 *
 */
class Guide {
    public static final String CSV_EXTENTION = ".csv";

    void go() {
        final Scanner sc = new Scanner(System.in, StandardCharsets.UTF_8.displayName());
        doDisclaimer(sc);
        final Crypto crypto = doSelectCryptoType(sc);
        final String filePath = doGenerateFile(sc, crypto);
        doEncryptionExample(filePath);
    }

    /**
     * Print a summary of the license and a warning about the dangers of managing
     * manually managing cryptocurrency keys.
     *
     * Suppress DM_EXIT because this application is intended to be executed alone.
     */
    @SuppressFBWarnings("DM_EXIT")
    void doDisclaimer(final Scanner sc) {
        println("------------------------------------ LICENSE ------------------------------------");
        println("| THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    |");
        println("| IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      |");
        println("| FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   |");
        println("| AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER        |");
        println("| LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, |");
        println("| OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE |");
        println("| SOFTWARE.                                                                     |");
        println("---------------------------------------------------------------------------------");
        println("");
        println("       --------------------------*** WARNING ***--------------------------");
        println("       | This software produces unencrypted cryptocurrency private keys. |");
        println("       | Knowledge of a private key associated to a balance grants the   |");
        println("       | ability to create transactions using that balance.              |");
        println("       |                                                                 |");
        println("       | DO NOT send a balance to the keys generated by this software    |");
        println("       | if you do not understand the risks.                             |");
        println("       -------------------------------------------------------------------");
        println("");
        askForInput("Ready to proceed? (y/N)");
        final String answer = sc.next();
        if (!"y".equals(answer)) {
            println("Aborted.");
            System.exit(0);
        }
    }

    Crypto doSelectCryptoType(final Scanner sc) {
        final Crypto[] values = Crypto.values();
        Crypto value = null;
        while (value == null) {
            println("Supported crypto-currency types:");
            for (int i = 0; i < values.length; i++) {
                println(" " + i + ". " + values[i].getAbbreviation());
            }
            askForInput("Which crypto?");
            final int menuSelection = sc.nextInt();
            try {
                value = values[menuSelection];
                println("Selected " + value);
            } catch (ArrayIndexOutOfBoundsException e) {
                println(getInvalidSelectionResponse(menuSelection));
            }
        }
        return value;
    }

    private String doGenerateFile(final Scanner sc, final Crypto crypto) {
        /*
         * Generate content
         */

        askForInput("How many addresses to generate?");
        final int addressCount = sc.nextInt();
        final List<ECKey> ecKeys = FileWallet.generateKeys(addressCount);

        /*
         * Save file
         */

        askForInput("Name (path) for file?");
        final String userFilePath = sc.next();
        final String filePath = userFilePath + CSV_EXTENTION;

        try {
            FileWallet.saveKeys(filePath, ecKeys, crypto.getNetParams(), crypto, sc);
        } catch (IOException e) {
            throw new AssertionError(e);
        }

        /*
         * Verify file
         */

        try {
            FileWallet.verify(filePath, crypto.getNetParams());
        } catch (IOException e) {
            throw new AssertionError(e);
        }

        /*
         * Create public addresses file
         */

        return filePath;
    }

    private void doEncryptionExample(final String filePath) {
        println("");
        println("The following is an encryption example WITHOUT ANY WARRANTY, that uses");
        println("an implementation of OpenPGP to encrypt the generated file.");
        println("Encrypt:");
        println("  gpg --armor --symmetric --cipher-algo AES256 --s2k-digest-algo SHA512 --s2k-count 65011712 " + filePath);
        println("  (The above command will prompt you for a passphrase. The passphrase");
        println("  should be long and random.)");
        println("Decrypt:");
        println("  gpg -d " + filePath);
    }

    private String getInvalidSelectionResponse(final int menuOptionNumber) {
        return "Selected " + menuOptionNumber + "; invalid selection.";
    }

    private void askForInput(final String s) {
        System.out.print(s + " ");
    }

    private void println(final String s) {
        System.out.println(s);
    }
}
